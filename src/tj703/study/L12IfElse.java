package tj703.study;

public class L12IfElse {
// 파일 11은 10복습했음.

   public static void main(String[] args) {
      // 제어문if ; 어떤 상황이 생기면, 그 상황을 판단해서 분기를 만들어내는 것
      int age = 17;
      // 비교연산자 ==

      // 자료형의 동등비교 연산은 완전히 같은지 물어본다. (정수int와 실수flout는 같지 않음)
      // 문자열을 제외한 모든 객체는 나자신을 비교하지 않는 이상 무조건 false다.
      // 그럼 문자열은??
      System.out.println("경민" == "경민"); // 어떨 땐 true, 어떨 땐 false
      // 왜 그런가? 면접 질문.  매번 새로 만들지 않기 때문이다.
      // 문자열은 보통 객체와 다르게, 리터럴하게 선언하면, 기본형처럼 이미 존재하는 객체를 참조하기 때문에, 동등비교연산시 true를 반환합니다.
      // 하지만 통신상황(소켓통신, "경민"을 통신으로 받았을 때)에서는 같은 객체를 참조한다는 보장이 없으므로, 종종 false가 나온다.
      // 자료형은 따라서 필드의 값을 비교하는 equals를 꼭 사용해야 한다.
      // [equals는 js에는 없는 기능 : js는 기본형만 비교연산 해야한다.
      //  자료형데이터(object)와 자료형데이터는 서로 비교할 수 없다.]

      // 비교형의 비교 연산은 값을 비교하므로, 정수와 실수가 같은 것으로 생각
      System.out.println(17 == 17.0);


      //ㅡㅡㅡㅡㅡㅡㅡㅡ if조건문
      // if 소괄호 안에 비교연산의 결과가 true일 때만, 내부 블럭(scope)을 실행
      // else:  if의 조건이 맞지 않으면 실행되는 블럭
      String b = "소맥"; // 변수의 기본값을 else나머지 조건으로 이미 설정한다!!
      if (age < 20) {
         b = "음료";
         System.out.println("음료수를 마신다");
      }
      if (age >= 20 && age < 30) {
         b = "소주";
         System.out.println("술을 마신다.");
      }
      // if조건식이 계속 나열되면, 모든 조건의 검사식을 진행한다. (조건이 곂치는 경우가 있음) => 그래서 else를 쓰는 것.


   }


// java에서 문자열 데이터에 대해서 구체적인 설명
   /* Java에서 문자열(String)은 일반적인 객체와 조금 다르게 다뤄집니다.
    문자열을 다룰 때, 문자열 리터럴을 사용하면 새로 객체를 만들지 않고 이미 존재하는 객체를 참조하게 됩니다.
    이 특징은 문자열을 비교할 때 중요한 차이를 만듭니다

   * 1. 문자열 리터럴: Java에서 문자열을 리터럴 방식으로 선언하면, 그 문자열은 **문자열 풀(string pool)**이라고 불리는 특별한 공간에 저장됩니다.
   * String str1 = "Hello";
     String str2 = "Hello";
     위 코드에서 "Hello"라는 문자열 리터럴은 문자열 풀에 저장됩니다.
     str1과 str2는 같은 문자열 "Hello"를 참조하게 되며, 사실 같은 객체를 가리키게 됩니다. 즉, 둘은 동일한 객체를 참조하는 것입니다.

   * 2. 문자열 비교 시 동등성: 문자열을 비교할 때 두 가지 방법이 있습니다
         == 연산자: 두 객체가 같은 객체(메모리 주소)를 참조하는지 확인합니다.
         .equals() 메서드: 두 문자열이 내용이 같은지 확인합니다.

   * 2.1 == 연산자 사용
      문자열 리터럴을 사용하면, 같은 문자열이 문자열 풀에 저장되어 있기 때문에 == 연산자를 사용한 비교에서 true를 반환합니다.
   String str1 = "Hello";
   String str2 = "Hello";
   System.out.println(str1 == str2);  // true
   위 코드에서 str1과 str2는 같은 객체를 참조하고 있기 때문에 == 연산자는 true를 반환합니다.

   * 2.2 new 키워드로 객체 생성
   반면, new 키워드를 사용하 같아도 서로 다른 객체이므로 == 연산자는 false를 반환합니다.
   String str1 = new String("Hello");
   String str2 = new String("Hello");
   System.out.println(str1 == str2);  // false
   위 코드에서는 str1과 str2가 각각 새로운 String 객체를 참조하므로 ==는 false를 반환합니다.

   * 3. String 객체는 재사용되는 이유
   Java에서는 문자열 리터럴이 문자열 풀에 저장되기 때문에, 같은 문자열 리터럴을 여러 번 사용해도 매번 새로운 객체를 만들지 않습니다.
   대신, 이미 존재하는 문자열 객체를 참조하게 되어 메모리 효율성이 높아집니다.
   String str1 = "Hello";
   String str2 = "Hello";
   이 두 변수는 실제로 같은 객체를 가리키고 있으며, "Hello"라는 문자열이 메모리에 한 번만 저장됩니다.
   이는 문자열이 불변(immutable) 객체라는 특성과도 관련이 있습니다.
   즉, 문자열을 변경할 수 없으므로, 여러 곳에서 동일한 문자열을 참조하더라도 안전하게 사용할 수 있습니다.

    * 4. 결론
   문자열 리터럴을 사용하면 Java는 이미 존재하는 객체를 참조하므로 == 연산자로 비교할 때 true를 반환합니다.
   new 키워드를 사용하면 매번 새로운 객체를 만들기 때문에 == 연산자는 false를 반환할 수 있습니다.
   문자열은 불변 객체이므로, 동일한 리터럴을 참조하면 메모리 효율적으로 관리됩니다.

   * */
}
