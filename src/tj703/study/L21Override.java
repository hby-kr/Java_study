package tj703.study;   /*
* 다형성  (중요!!!)  polymorphism [ pɑ̀limɔ́:rfizm ]
 - 다형성이란, 하나의 메서드나 클래스가 다수의 형태로 동작할 수 있는 능력을 의미.
 - 같은 이름의 메서드가 서로 다른 객체에서 다르게 동작할 수 있는 능력.

[ 다형성은 셋. 타입의 다형성 / overload  / override ]

오버로딩(Overloading, 과도하게 싣기): 하나의 클래스 내부에서 같은 이름을 가진 메서드를 여러 번 정의하되, 매개변수의 개수나 타입에 따라 여러 가지로 정의하는 것.
오버라이딩(Overriding, 덮어쓰다): 부모 클래스의 메서드를 상속받은 자식 클래스에서 재정의하여 동작을 변경하는 것.


1. (클래스의, 타입의) 다형성
Object o = new String()  // 이때 o는 String 객체의 Object 성향만 참조한다. / 업캐스팅(Upcasting)
String s = new String()  // 이때 s는 String 객체 전체의 데이터를 참조한다.
이 경우, o는 String 객체를 참조하지만, Object 클래스에서 정의된 메서드만 사용할 수 있습니다.
   String 클래스에서 제공하는 String 특화된 메서드는 사용할 수 없습니다.
반면, s는 String 객체의 전체 성질을 참조하고,
   String 클래스에 정의된 특화된 메서드들(예: length(), charAt(), substring() 등)을 사용할 수 있습니다.

2. (생성자의, 메서드의) 다형성  =  메서드 오버로딩 (Method Overloading)
add (a)
add (a, b)
// 하나의 메서드의 이름으로 다른 매개변수를 가진 생성자를 여럿 만들 수 있다.

ㅡㅡㅡㅡㅡ
>> (메서드의) 다형성은 두 가지로 나눌 수 있음.
크게 메서드 오버로딩(Method Overloading)과 메서드 오버라이딩(Method Overriding)로.

- 메서드 오버로딩 (Method Overloading)
동일한 이름의 메서드를 여러 번 정의하는 방식입니다. 다만, 매개변수의 개수나 타입이 달라야 합니다.
즉, 같은 메서드 이름을 사용하되, 매개변수의 형태에 따라 서로 다른 동작을 하게 만드는 것입니다.

override : 부모와 자식이 같은 이름의 함수를 갖지만, 자식이 재정의하면 자식의 함수가 호출되는 것. 이 역시 객체지향 문법 다형성에 해당한다.

- 메서드 오버라이딩 (Method Overriding)
상속을 통해 부모 클래스에서 정의된 메서드를 자식 클래스에서 재정의하는 방식입니다.
부모 클래스에서 정의된 메서드의 구현을 자식 클래스에서 수정하여 다르게 동작하게 만들 수 있습니다.
오버라이딩을 통해 다형성이 실현되는 핵심 포인트는
실제 (상속받은 자식) 객체의 타입에 따라 호출되는 메서드가 달라진다는 점입니다.
이 특징은 부모 클래스와 자식 클래스 간에 메서드의 이름은 같지만, 실제 객체에 따라 다른 동작을 하게 만듭니다.

 */


public class L21Override {

   class A {
      public int add(int a, int b) {
         int add = 0;
         add = a + b;
         return add;
      }
   }

   class B extends A {

      // add 메서드가 마음에 들지 않아서, 재정의하기로 하는 경우
      @Override // annotation(컴파일러가 부모의 함수를 재정의하고 있는지, 검사하고 컴파일하게 하는것
      public int add(int a, int b) {
         int add = super.add(a, b); // new A().add(a,b) 부모 것을 한번 호출하고 그 이후에 재정의
         add = a + b + b + a;  // 재정의
         return add;
      }

   }

   public static void main(String[] args) {
      L21Override o = new L21Override();
      B b = o.new B();
      System.out.println(b.add(15, 50));
      A a = b; // 부모의 필드만 필요하지 B의 필드는 필요없을 때.
      // b가 참조하는 객체가 A로 형변환했다? false
      // b를 참조하던 객체를, 타입이 A인 a가 참조했다. true

      int add = a.add(1, 5);
      System.out.println(add);
/*
a의 타입은 class A인데, 어째서 class B의 메서드를 사용하게 되는가?

그 이유는 다형성과 동적 메서드 디스패치(Dynamic Method Dispatch) 때문.
a의 타입은 classA로 선언되어 있지만, 실제로 a는 B 타입의 객체인 b를 참조하고 있습니다.
런타임 시점에서 a는 B 클래스의 객체를 참조하는 것이 됩니다.
자바에서는 메서드를 호출할 때, 실제 객체의 타입을 기준으로 호출할 메서드를 결정합니다.
즉, a의 타입이 A여도, 실제로 a가 참조하는 객체가 B 타입이므로, B 클래스에서 오버라이드한 add 메서드가 호출됩니다.
이것이 자바에서의 동적 메서드 디스패치(Dynamic Method Dispatch)라고 하는, 자바에서 메서드를 호출할 때 적용되는 규칙 중 하나이다. 메서드를 호출할 때 실제 객체의 타입에 따라 어떤 메서드를 호출할지 결정합니다.

왜 이런 방식으로 동작하는가? 다형성(Polymorphism)을 구현하기 위해서입니다.
부모 클래스의 메서드를 자식 클래스에서 재정의(Override)하여, 참조 변수의 타입과 상관없이 실제 객체의 타입에 맞는 메서드를 실행하도록 합니다.

1. 컴파일 시점 (Compile-time): 컴파일 시점은 코드를 작성한 후, 프로그램을 실행 가능한 형태로 변환할 때.
이 과정은 소스 코드가 컴퓨터가 이해할 수 있는 기계어로 번역되는 과정.  주로 문법 오류나 타입 체크가 이루어지는 시점.
2. 런타임 시점 (Run-time): 런타임 시점은 프로그램이 실제로 실행될 때 발생하는 시점. 컴파일이 끝난 후, 실행 중에 발생하는 일들이 처리

따라서 위에서, 컴파일 시에 a는 class A의 인스턴스 객체지만, 런타임 시에 classB의 인스턴스인 b를 참조하므로 b가 가진 (오버라이딩 된)메서드를 사용하게 된다.
 <동적 메서드 디스패치(Dynamic Method Dispatch)> (동적 바인딩(dynamic binding))

동적 메서드 디스패치는 런타임 시점에, 객체를 생성하면서 할당된 메모리(v-table)에서 해당 객체의 실제 타입에 따라 호출할 메서드를 결정하는 방식입니다. (가상 메서드 테이블(Virtual Method Table)의 약자)
자바와 같은 언어에서 다형성(특히 오버라이딩된 메서드 호출)에 대한 처리를 v-table을 통해 구현하는데,
이 방식은 실행 중에(런타임) 호출할 메서드를 결정하는 데 중요한 역할을 합니다.
자바와 같은 객체 지향 언어에서 다형성을 지원하는 핵심적인 메커니즘 중 하나입니다.

cf. 정적 메서드 디스패치 / 정적 바인딩(static binding)
정적 메서드 디스패치는 컴파일 시점에, 메서드의 매개변수 타입에 따라 호출할 메서드를 결정하는 방식입니다. 주로 오버로딩된 메서드에서 발생합니다.

필드는 동적으로 바인딩 되지 않는다. 오버라이딩이라는 말도 없다.
필드는 필드는 정적 바인딩(static binding)을 사용하며, 자식 클래스에서 필드의 값을 변경할 수 있지만, 이를 "오버라이드"라고 부르지 않습니다. 필드는 메서드와 달리 객체가 무엇인지와 상관없이 컴파일 타임에 결정됩니다.

*/

   }
}
